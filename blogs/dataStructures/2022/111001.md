---
title: 数据结构与算法——day10
date: 2022-11-10 16:58
tags: 
 - dataStructures
 - algorithms
categories: 
 - frontEnd
---

## 基于图的算法

### 最短路径算法

#### Dijkstra算法

> Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法

![邻接矩阵](./2022-11-11-13-52-35.png)

图示的图对应的邻接矩阵代码如下

```ts
const graph = [
  [0, 2, 4, 0, 0, 0],
  [0, 0, 1, 4, 2, 0],
  [0, 0, 0, 0, 3, 0],
  [0, 0, 0, 0, 0, 2],
  [0, 0, 0, 3, 0, 2],
  [0, 0, 0, 0, 0, 0],
]
```

dijkstra算法实现如下

```ts
const INF = Number.MAX_SAFE_INTEGER

const minDistance = (dist: number[], visited: boolean[]) => {
  let min = INF
  let minIndex = -1

  for (let v = 0; v < dist.length; v++) {
    if (visited[v] === false && dist[v] <= min) {
      min = dist[v]
      minIndex = v
    }
  }

  return minIndex
}

export const dijkstra = (graph: number[][], src: number) => {
  const dist: number[] = []
  const visited: boolean[] = []
  const length = graph.length

  // 初始化所有顶点距离源点距离都是无穷大，同时所有顶点都未访问
  for (let i = 0; i < length; i++) {
    dist[i] = INF
    visited[i] = false
  }

  // 源点到自己的路径置为0
  dist[src] = 0

  for (let i = 0; i < length - 1; i++) {
    // 找出距离源点最小距离的顶点u
    const u = minDistance(dist, visited)

    // 将该顶点置为已经访问（后续由于已经访问过该顶点，所以minDistance不会再次返回该顶点索引）
    visited[u] = true

    // 遍历顶点u的所有邻接点v
    for (let v = 0; v < length; v++) {
      // 1. !visited[v]表示顶点未被访问
      // 2. graph[u][v] !== 0 && dist[u] !== INF表示存在邻接点路径
      // 3. dist[u] + graph[u][v] < dist[v] 已访问顶点u到源点src的距离dist[u]加上已访问顶点u到邻接点v的距离是否小于 v到源点src的距离，若小于那么则跟新v到源点的距离为u到原点距离加上u到v的距离
      if (!visited[v] && graph[u][v] !== 0 && dist[u] !== INF && dist[u] + graph[u][v] < dist[v])
        dist[v] = dist[u] + graph[u][v]
    }
  }

  return dist
}
```

分析过程如下

* dist数组存放顶点距离源点最短距离的数值
* visited数组存放顶点是否访问过（避免重复访问）
* 内部循环控制二维数组的横向遍历邻接点并比较其与源点距离并更新
* 外部循环控制二维数组的纵向（注意`length-1`， 我也不是很懂为啥，但是下图的分析就是能证明无需外部多一次循环😂）

![分析流程图](./Dijkstra.png)

#### Floyd-Warshall算法

> Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法

### 最小生成树

#### Prim算法

#### Kruskal算法
