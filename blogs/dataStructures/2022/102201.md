---
title: æ•°æ®ç»“æ„ä¸ç®—æ³•â€”â€”day3
date: 2022-10-22 10:12
tags: 
 - dataStructures
 - algorithms
categories: 
 - frontEnd
---

## é“¾è¡¨

> é“¾è¡¨çš„å˜ç§ï¼šåŒå‘é“¾è¡¨ã€å¾ªç¯é“¾è¡¨ã€æœ‰åºé“¾è¡¨<br />å¯¹æ¯”äºæ•°ç»„æ¥è¯´ï¼Œå¥½å¤„å°±æ˜¯æ·»åŠ æˆ–ç§»é™¤å…ƒç´ æ— éœ€å¯¹åŸæœ‰å…ƒç´ è¿›è¡Œç§»åŠ¨

### æ•°æ®ç»“æ„å®ç°

#### é“¾è¡¨

èŠ‚ç‚¹ç±»

```ts
export class Node<T> {
  constructor(public element: T, public next?: Node<T>) {}
}
```

é»˜è®¤çš„ç›¸ç­‰åˆ¤æ–­å‡½æ•°åŠç±»å‹å®šä¹‰

```ts
export type IEqualsFunction<T> = (a: T, b: T) => boolean

export function defaultEquals<T>(a: T, b: T): boolean {
  return a === b
}
```

é“¾è¡¨ç±»

```ts
export class LinkdeList<T> {
  // é•¿åº¦ç»Ÿè®¡
  protected count = 0
  // å¤´æŒ‡é’ˆ
  protected head: Node<T> | undefined

  // equalsFnæ˜¯è‡ªå·±å®šä¹‰çš„åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç›¸ç­‰çš„æ–¹æ³•ï¼ˆå› ä¸ºå…ƒç´ çš„ç±»å‹æ˜¯å˜åŒ–çš„ï¼Œæ‰€ä»¥åˆ¤æ–­ç›¸ç­‰çš„æ–¹æ³•éœ€è¦è‡ªå·±ç¼–å†™ï¼‰
  constructor(protected equalsFn: IEqualsFunction<T> = defaultEquals) {}

  // é“¾è¡¨å°¾éƒ¨æ·»åŠ å…ƒç´ 
  push(ele: T) {
    const node = new Node(ele)

    let current

    // é“¾è¡¨ä¸ºç©ºçš„æ—¶å€™
    if (this.head == null) {
      this.head = node
    }
    else {
      current = this.head

      while (current.next)
        current = current.next

      current.next = node
    }

    this.count++
  }

  getElementAt(index: number) {
    if (index >= 0 && index <= this.count) {
      let node = this.head

      for (let i = 0; i < index && node != null; i++)
        node = node.next

      return node
    }

    return undefined
  }

  removeAt(index: number) {
    if (index >= 0 && index < this.count) {
      let current = this.head

      // ç§»é™¤ç¬¬ä¸€é¡¹ï¼ˆæ³¨æ„å¤´æŒ‡é’ˆåªä¼šåœ¨ç§»é™¤ç¬¬ä¸€é¡¹çš„æ—¶å€™å‘ç”Ÿå˜åŒ–ï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼‰
      if (index === 0) { this.head = current?.next }
      else {
        // è·å–å½“å‰ç´¢å¼•çš„å‰ä¸€ä¸ªç´¢å¼•å…ƒç´ 
        const previous = this.getElementAt(index - 1)
        // å½“å‰æŒ‡å‘previousçš„ä¸‹ä¸€ä¸ª
        current = previous?.next
        // åˆ‡é™¤ä¸­é—´çš„å…ƒç´ 
        previous!.next = current?.next
      }

      // è®¡æ•°å‡ä¸€å¹¶è¿”å›å½“å‰å…ƒç´ 
      this.count--
      return current?.element
    }

    // ä¸åˆæ³•æ—¶è¿”å›undefined
    return undefined
  }

  insert(ele: T, index: number) {
    if (index >= 0 && index <= this.count) {
      const node = new Node(ele)

      if (index === 0) {
        const current = this.head
        node.next = current
        this.head = node
      }
      else {
        const previous = this.getElementAt(index - 1)
        const current = previous?.next
        node.next = current
        previous!.next = node
      }

      this.count++
      return true
    }

    return false
  }

  indexOf(ele: T) {
    let current = this.head

    for (let i = 0; i < this.count && current != null; i++) {
      if (this.equalsFn(ele, current.element))
        return i

      current = current.next
    }

    return -1
  }

  remove(ele: T) {
    const index = this.indexOf(ele)
    return this.removeAt(index)
  }

  size() {
    return this.count
  }

  isEmpty() {
    return this.size() === 0
  }

  getHead() {
    return this.head
  }

  clear() {
    this.head = undefined
    this.count = 0
  }

  toString() {
    if (this.head == null)
      return ''

    let objString = `${this.head.element}`
    let current = this.head.next
    for (let i = 1; i < this.size() && current != null; i++) {
      objString = `${objString},${current.element}`
      current = current.next
    }
    return objString
  }
}
```

* æ ¸å¿ƒæ–¹æ³•`push` `getElementAt` `removeAt` `insert`

#### åŒå‘é“¾è¡¨

èŠ‚ç‚¹ç±»

```ts
export class DoublyNode<T> extends Node<T> {
  constructor(
    public element: T,
    public next?: DoublyNode<T>,
    public prev?: DoublyNode<T>,
  ) {
    super(element, next)
  }
}
```

é»˜è®¤çš„ç›¸ç­‰åˆ¤æ–­å‡½æ•°åŠç±»å‹å®šä¹‰

```ts
export type IEqualsFunction<T> = (a: T, b: T) => boolean

export function defaultEquals<T>(a: T, b: T): boolean {
  return a === b
}
```

åŒå‘é“¾è¡¨ç±»

```ts
export class DoublyLinkedList<T> extends LinkdeList<T> {
  protected head: DoublyNode<T> | undefined
  protected tail: DoublyNode<T> | undefined

  constructor(protected equalsFn: IEqualsFunction<T> = defaultEquals) {
    super(equalsFn)
  }

  push(ele: T) {
    const node = new DoublyNode(ele)

    // ä¸ºç©ºé“¾è¡¨
    if (this.head == null) {
      this.head = node
      this.tail = node
    }
    else {
      this.tail!.next = node
      node.prev = this.tail
      this.tail = node
    }

    this.count++
  }

  insert(ele: T, index: number) {
    if (index >= 0 && index <= this.count) {
      const node = new DoublyNode(ele)

      let current = this.head

      // å°¾ HEAD <-> B
      if (index === 0) {
        if (this.head == null) {
          this.head = node
          this.tail = node
        }
        else {
          node.next = current
          current!.prev = node
          this.head = node
        }
      }
      // å°¾ B <-> TAIL
      else if (index === this.count) {
        current = this.tail
        current!.next = node
        node.prev = current
        this.tail = node
      }
      // ä¸­é—´ A <-> B <-> C
      else {
        const previous = this.getElementAt(index - 1)
        current = previous?.next
        node.next = current
        previous!.next = node
        current!.prev = node
        node.prev = previous
      }

      this.count++
      return true
    }

    return false
  }

  removeAt(index: number) {
    if (index >= 0 && index < this.count) {
      let current = this.head

      // å¤´
      if (index === 0) {
        this.head = this.head?.next

        if (this.count === 1)
          this.tail = undefined

        else
          this.head!.prev = undefined
      }
      // å°¾
      else if (index === this.count - 1) {
        current = this.tail
        this.tail = current?.prev
        this.tail!.next = undefined
      }
      // ä¸­é—´
      else {
        current = this.getElementAt(index)
        const previous = current?.prev
        previous!.next = current?.next
        current!.next!.prev = previous
      }

      this.count--
      return current!.element
    }

    return undefined
  }

  indexOf(ele: T) {
    let current = this.head
    let index = 0

    while (current) {
      if (this.equalsFn(ele, current.element))
        return index
      index++
      current = current.next
    }

    return -1
  }

  getHead() {
    return this.head
  }

  getTail() {
    return this.tail
  }

  clear() {
    super.clear()
    this.tail = undefined
  }

  toString() {
    if (this.head == null)
      return ''

    let objString = `${this.head.element}`
    let current = this.head.next
    while (current != null) {
      objString = `${objString},${current.element}`
      current = current.next
    }
    return objString
  }

  inverseToString() {
    if (this.tail == null)
      return ''

    let objString = `${this.tail.element}`
    let previous = this.tail.prev
    while (previous != null) {
      objString = `${objString},${previous.element}`
      previous = previous.prev
    }
    return objString
  }
}
```

#### å¾ªç¯é“¾è¡¨

å¾ªç¯é“¾è¡¨å­˜åœ¨ä¸¤ç§ï¼Œå•å‘å¾ªç¯é“¾è¡¨ä»¥åŠåŒå‘å¾ªç¯é“¾è¡¨

å•å‘ï¼š
![å•å‘](./2022-10-22-14-40-32.png)

```ts
export class CircularLinkedList<T> extends LinkdeList<T> {
  constructor(protected equalsFn: IEqualsFunction<T> = defaultEquals) {
    super(equalsFn)
  }

  push(ele: T) {
    const node = new Node(ele)
    let current

    if (this.head == null) {
      this.head = node
    }
    else {
      current = this.getElementAt(this.size() - 1)
      current!.next = node
    }

    node.next = this.head
    this.count++
  }

  insert(ele: T, index: number): boolean {
    if (index >= 0 && index <= this.count) {
      const node = new Node(ele)
      let current = this.head

      // å¤´éƒ¨æ’å…¥
      if (index === 0) {
        // ç©ºçš„é“¾è¡¨
        if (this.head == null) {
          this.head = node
          node.next = this.head
        }
        // éç©ºé“¾è¡¨
        else {
          node.next = current
          // æœ€åä¸€ä¸ªèŠ‚ç‚¹
          current = this.getElementAt(this.size() - 1)
          this.head = node
          current!.next = this.head
        }
      }
      // å…¶ä½™ä½ç½®æ’å…¥
      else {
        const previous = this.getElementAt(index - 1)
        node.next = previous?.next
        previous!.next = node
      }

      this.count++
      return true
    }

    return false
  }

  removeAt(index: number): T | undefined {
    if (index >= 0 && index < this.count) {
      let current = this.head

      // åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ 
      if (index === 0) {
        // ä»…ä»…å­˜åœ¨ä¸€ä¸ªå…ƒç´ 
        if (this.size() === 1) {
          this.head = undefined
        }
        else {
          const removed = this.head
          current = this.getElementAt(this.size() - 1)
          this.head = this.head?.next
          current!.next = this.head
          current = removed
        }
      }
      // åˆ é™¤å…¶ä½™ä½ç½®çš„å…ƒç´ 
      else {
        const previous = this.getElementAt(index - 1)
        current = previous?.next
        previous!.next = current?.next
      }

      this.count--
      return current?.element
    }

    return undefined
  }
}
```

åŒå‘ï¼š
![åŒå‘](./2022-10-22-14-41-00.png)

ğŸ˜‚ä»£ç å®ç°ç•¥è¿‡ï¼ˆä¸æ˜¯å·æ‡’åªæ˜¯è§‰å¾—å°†æ›´å¤šç²¾åŠ›æŠ•å…¥åˆ°åé¢çš„å­¦ä¹ æ›´é‡è¦ï¼‰

#### æœ‰åºé“¾è¡¨

é»˜è®¤æ¯”è¾ƒå‡½æ•°ä»¥åŠç±»å‹å’Œæšä¸¾å˜é‡

```ts
export type ICompareFunction<T> = (a: T, b: T) => number

export enum Compare {
  LESS_THAN = -1,
  BIGGER_THAN = 1,
  EQUALS = 0,
}

export function defaultCompare<T>(a: T, b: T): number {
  if (a === b)
    return Compare.EQUALS

  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
}
```

æœ‰åºé“¾è¡¨

```ts
export class SortedLinkedList<T> extends LinkdeList<T> {
  constructor(
    protected equalsFn: IEqualsFunction<T> = defaultEquals,
    protected compareFn: ICompareFunction<T> = defaultCompare,
  ) {
    super(equalsFn)
  }

  private getIndexNextSortedElement(ele: T) {
    let current = this.head
    let i = 0

    for (; i < this.size() && current; i++) {
      const comp = this.compareFn(ele, current.element)
      // NOTE: è¿™é‡Œçš„é¡ºåºæ˜¯å°åˆ°å¤§ï¼ˆå¯ä»¥æ”¹å˜è¿™é‡Œçš„æšä¸¾å€¼æ”¹å˜æ’åºé¡ºåºï¼‰
      if (comp === Compare.LESS_THAN)
        return i

      current = current.next
    }

    return i
  }

  push(ele: T): void {
    if (this.isEmpty()) {
      super.push(ele)
    }
    else {
      const index = this.getIndexNextSortedElement(ele)
      super.insert(ele, index)
    }
  }

  insert(ele: T, index: number): boolean {
    if (this.isEmpty())
      return super.insert(ele, index)

    index = this.getIndexNextSortedElement(ele)
    return super.insert(ele, index)
  }
}
```

### åº”ç”¨ç¤ºä¾‹

#### ä½¿ç”¨åŒå‘é“¾è¡¨å®ç°æ ˆ

<span style="color: pink;">ä¸ºä»€ä¹ˆä½¿ç”¨åŒå‘é“¾è¡¨è€Œä¸æ˜¯æ™®é€šé“¾è¡¨ï¼Ÿ</span> å°¾éƒ¨çš„æ’å…¥ä»¥åŠåˆ é™¤æ“ä½œä¸éœ€è¦å¾ªç¯é“¾è¡¨ä¸­çš„å…ƒç´ ï¼Œå› ä¸ºtailæŒ‡é’ˆè®°å½•äº†å¯¹åº”çš„ä½ç½®ï¼Œåªéœ€æ“ä½œtailæŒ‡é’ˆå°±å¥½äº†ï¼ˆæ—¶é—´å¤æ‚åº¦ O(1)ï¼‰

```ts
export class Stack<T> {
  private items: DoublyLinkedList<T>

  constructor() {
    this.items = new DoublyLinkedList<T>()
  }

  push(element: T) {
    this.items.push(element)
  }

  pop() {
    if (this.isEmpty())
      return undefined

    const result = this.items.removeAt(this.size() - 1)
    return result
  }

  peek() {
    if (this.isEmpty())
      return undefined

    return this.items.getTail()?.element
  }

  isEmpty() {
    return this.items.isEmpty()
  }

  size() {
    return this.items.size()
  }

  clear() {
    this.items.clear()
  }

  toString() {
    return this.items.toString()
  }
}
```
