---
title: 数据结构与算法——day11
date: 2022-11-18 10:11
tags: 
 - dataStructures
 - algorithms
categories: 
 - frontEnd
---

## 排序和搜索算法

### 冒泡排序

> 时间复杂度 O(n^2)

辅助函数 `swap` 交换数组中的元素位置：

```ts
export function swap(array: any[], a: number, b: number) {
  [array[a], array[b]] = [array[b], array[a]]
}
```

辅助函数 `defaultCompare` 比较 a 与 b 的大小：

```ts
export enum Compare {
  LESS_THAN = -1,
  BIGGER_THAN = 1,
  EQUALS = 0,
}

export function defaultCompare<T>(a: T, b: T): number {
  if (a === b)
    return Compare.EQUALS

  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
}
```

排序算法实现：

```ts
export function bubbleSort<T>(array: T[], compareFn = defaultCompare) {
  const { length } = array

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length - 1; j++) {
      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN)
        swap(array, j, j + 1)
    }
  }

  return array
}
```

图示分析如下：

![冒泡排序](./2022-11-18-10-56-17.png)

可以发现红色部分其实是未必要的比较，于是乎对代码进行优化如下

```ts
export function modifiedBubbleSort<T>(array: T[], compareFn = defaultCompare) {
  const { length } = array

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length - 1 - i; j++) {
      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN)
        swap(array, j, j + 1)
    }
  }

  return array
}
```

接着上 `vitest` 测试结果如下：

```ts
const arr = [8, 7, 5, 4, 3, 2]

test('bubbleSort', () => {
  expect(modifiedBubbleSort(arr)).toMatchInlineSnapshot(`
    [
      2,
      3,
      4,
      5,
      7,
      8,
    ]
  `)
})
```

### 选择排序

原理：选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位

代码实现如下：

```ts
import { swap } from './heap'
import { Compare, defaultCompare } from './sortedLinkedList'

export const selectionSort = (array: any[], compareFn = defaultCompare) => {
  const { length } = array
  let indexMin

  for (let i = 0; i < length - 1; i++) {
    indexMin = i

    for (let j = i; j < length; j++) {
      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN)
        indexMin = j
    }
    if (i !== indexMin)
      swap(array, i, indexMin)
  }

  return array
}

```

vitest测试如下：

```ts
test('selectionSort', () => {
  const arr = [8, 7, 5, 4, 3, 2]

  expect(selectionSort(arr)).toMatchInlineSnapshot(`
    [
      2,
      3,
      4,
      5,
      7,
      8,
    ]
  `)
})
```

![selectionSort](./2022-11-19-16-58-21.png)

### 插入排序

原理：从第二位开始提取为temp并循环比较与前者的大小，若小于前者，那么将前者赋予当前位置，结束后得到temp应该被插入的位置

代码实现如下：

```ts
import { Compare, defaultCompare } from './sortedLinkedList'

export const insertionSort = (array: any[], compareFn = defaultCompare) => {
  const { length } = array
  let temp

  for (let i = 0; i < length; i++) {
    let j = i
    temp = array[i]

    while (j > 0 && compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) {
      array[j] = array[j - 1]
      j--
    }

    array[j] = temp
  }

  return array
}

```

vitest测试如下：

```ts
test('insertionSort', () => {
  const arr = [8, 7, 5, 4, 3, 2]

  expect(insertionSort(arr)).toMatchInlineSnapshot(`
    [
      2,
      3,
      4,
      5,
      7,
      8,
    ]
  `)
})
```

![insertionSort](./2022-11-24-12-22-57.png)

### 归并排序

原理：原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组

归并排序的实现大致两个过程（一个函数用来进行拆分，另一个函数用来合并）

`merge`: 合并函数

```ts
function merge<T>(left: T[], right: T[], compareFn: ICompareFunction<T>) {
  let i = 0
  let j = 0
  const result = []

  // 注意这里使用 i j 进行比较 left数组与right数组 中的元素
  while (i < left.length && j < right.length)
    result.push(compareFn(left[i], right[j]) === Compare.LESS_THAN ? left[i++] : right[j++])

  // 判断是left先遍历完毕还是right，
  // 1. 若为right先遍历完毕也就是此时 i < left.length 那么说明left余下部分都是大于right中元素
  // 2. 若为left先遍历完毕也就是此时 i >= left.length 那么说明right余下部分都是大于left中元素
  return result.concat(i < left.length ? left.slice(i) : right.slice(j))
}
```

`mergeSort`: 拆分函数

```ts
export function mergeSort<T>(array: T[], compareFn = defaultCompare): T[] {
  // 结束条件就是array.length === 1
  if (array.length > 1) {
    const { length } = array

    // 数组中间部分
    const middle = Math.floor(length / 2)

    // 0 ~ middle
    const left = mergeSort(array.slice(0, middle), compareFn)

    // middle ~ array.length
    const right = mergeSort(array.slice(middle, length), compareFn)

    // 左右进行合并
    array = merge(left, right, compareFn)
  }

  return array
}
```

vitest测试如下

```ts
test('mergeSort', () => {
  const arr = [8, 7, 6, 5, 4, 3, 2, 1]

  expect(mergeSort(arr)).toMatchInlineSnapshot(`
    [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
    ]
  `)
})
```

![mergeSort](./2022-11-28-12-31-53.png)

### 快速排序

原理：

* 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值
* 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作
* 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序

<span style="color: pink;">你只要知道快速排序通常比所有的 O(nlog(n)) 时间复杂度排序算法中性能更好！</span>

`partition`: 划分函数

```ts
function partition(array: any[], left: number, right: number, compareFn: ICompareFunction<any>) {
  const pivot = array[Math.floor((right + left) / 2)]
  let i = left
  let j = right

  // 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大时，交换它们，并且此时左指针索引没有右指针索引大
  while (i <= j) {
    while (compareFn(array[i], pivot) === Compare.LESS_THAN)
      i++

    while (compareFn(array[j], pivot) === Compare.BIGGER_THAN)
      j--

    if (i <= j) {
      swap(array, i, j)
      i++
      j--
    }
  }

  return i
}
```

`quickSort`: 排序函数

```ts
function quick(array: any[], left: number, right: number, compareFn: ICompareFunction<any>) {
  let index

  // 中止条件 <= 1
  if (array.length > 1) {
    // partition返回 左指针的索引
    index = partition(array, left, right, compareFn)

    if (left < index - 1)
      // 左侧再进行划分
      quick(array, left, index - 1, compareFn)

    if (index < right)
      // 右侧再进行划分
      quick(array, index, right, compareFn)
  }

  return array
}

export const quickSort = (array: any[], compareFn = defaultCompare) => {
  return quick(array, 0, array.length - 1, compareFn)
}

```

使用vitest测试如下

```ts
test('quickSort', () => {
  const arr = [3, 5, 1, 6, 4, 7, 2]

  expect(quickSort(arr)).toMatchInlineSnapshot(`
    [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
    ]
  `)
})
```

分析图如下

* 第一次划分得到`index=5`，下次就是 0到4开始划分

![第一次划分](./2022-11-29-19-30-15.png)

* 第二次划分得到`index=1`，下次就是 1到4开始划分

![第二次划分](./2022-11-29-19-39-26.png)

* 第三次划分得到`index=3`，下次就是 1到2开始划分

![第三次划分](./2022-11-29-19-59-53.png)

* 第四次划分得到`index=2`，此时左侧quick完毕了，该右侧quick了，下次从 3到4开始

![第四次划分](./2022-11-29-20-14-00.png)

* 第五次划分得到`index=4`， 依然是右侧的quick，下次从 5到6开始

![第五次划分](./2022-11-29-20-20-33.png)

* 第六次划分得到`index=6`，此时由于left=5且right=6，不满足条件于是直接return

![第六次划分](./2022-11-29-20-29-52.png)
